/**
 * Defines a base OthelloPlayer class that specifies the board and token.
 *
 * @author  T.Sergeant
 * @version For AI
 *
*/
import java.io.IOException;
//import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.SocketException;
import java.util.Scanner;

public class MattOthelloPlayer extends OthelloPlayer
{
    //protected Board board; // the board the player is using
    //protected char token;  // the token the player is using
    int nummoves;
    Socket socket;
    PrintWriter out;
    Scanner in;

    // My own version of board with more public methods to get around the fact that I can't edit Board.java
    

    /**
     * Set the board and token.
     */
    public MattOthelloPlayer(Board board, char token) {
        super(board, token);

        if (token == 'X') {
            nummoves = 0;
        }
        else {
            nummoves = 1;
        }
        
        System.out.println("Initializing MattOthelloPlayer...");
        try {
            socket = new Socket("localhost", 12321);
            out = new PrintWriter(socket.getOutputStream());
            in = new Scanner(socket.getInputStream());
            System.out.println("Done.");
        }
        catch (IOException e) {
            System.out.println("Error initializing player:");
            e.printStackTrace();
        }
    }

    /**
     * We represent the player by their token.
     */
    @Override
    public String toString()
    {
        return ""+token;
    }

    public char[][] boardCopy(Board board) {
        int rows = board.grid.length;
        int cols = board.grid[0].length;
        char[][] copy = new char[rows][cols];

        for (int row = 0; row < copy.length; row++) {
            for (int col = 0; col < copy[0].length; col++) {
                copy[row][col] = board.grid[row][col];
            }
        }

        return copy;
    }

    public char[][] boardCopy(AlphaBetaBoard board) {
        int rows = board.grid.length;
        int cols = board.grid[0].length;
        char[][] copy = new char[rows][cols];

        for (int row = 0; row < copy.length; row++) {
            for (int col = 0; col < copy[0].length; col++) {
                copy[row][col] = board.grid[row][col];
            }
        }

        return copy;
    }
    
    public String getBoardStr(AlphaBetaBoard current) {
        String boardStr = "";
        
        for (int i = 0; i < current.grid.length; i++) {
            boardStr += String.valueOf(current.grid[i]);
        }
        
        boardStr += "_";
        boardStr += String.valueOf(current.sockToken);
        boardStr += "_";
        boardStr += String.valueOf(current.moveCount);
        
        return boardStr;
    }

    /**
     * Every OthelloPlayer needs to specify how they will make a move.
     *
     * <p>This method will need to call board.makeMove() as part of it's
     * action to update the board and to get a valid Move object.</p>
     *
     * @return a Move object generated by board.makeMove()
     */
    public Move makeMove() {
        long startTime = System.currentTimeMillis();
        
        AlphaBetaBoard current = new AlphaBetaBoard(boardCopy(this.board), nummoves);
        current.sockToken = this.token;
        
        String chosenOne = "";
             
        System.out.println("Sending board.");
        
        String boardStr = getBoardStr(current);
        
        out.println(boardStr);
        out.flush();
        
        // Get the results.
        System.out.println("Done. Waiting for results...");

        chosenOne = in.nextLine();
        
        System.out.println("I picked " + chosenOne);

        // Add 2 to moves to keep an accurate count of moves made.        
        nummoves += 2;
        long endTime = System.currentTimeMillis();
        long timeTaken = (endTime - startTime);
        //timeTaken /= 1000.0;
        System.out.println("Choice made in " + timeTaken + "ms");
        
        Move bestChoice;
        
        if (!chosenOne.equals("")) {
            bestChoice = board.makeMove(token, chosenOne);
        }
        else {
            bestChoice = null;
        }

        return bestChoice;
    }
}


